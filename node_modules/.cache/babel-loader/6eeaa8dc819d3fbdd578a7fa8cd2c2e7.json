{"ast":null,"code":"\"use strict\";\n\nvar deferred_1 = require(\"./lib/deferred\");\n\nvar once_1 = require(\"./lib/once\");\n\nvar promise_or_callback_1 = require(\"./lib/promise-or-callback\");\n\nfunction wrapPromise(fn) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var callback;\n    var lastArg = args[args.length - 1];\n\n    if (typeof lastArg === \"function\") {\n      callback = args.pop();\n      callback = once_1.once(deferred_1.deferred(callback));\n    } // I know, I know, this looks bad. But it's a quirk of the library that\n    // we need to allow passing the this context to the original function\n    // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n    // @ts-ignore: this has an implicit any\n\n\n    return promise_or_callback_1.promiseOrCallback(fn.apply(this, args), callback); // eslint-disable-line no-invalid-this\n  };\n}\n\nwrapPromise.wrapPrototype = function (target, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var ignoreMethods = options.ignoreMethods || [];\n  var includePrivateMethods = options.transformPrivateMethods === true;\n  var methods = Object.getOwnPropertyNames(target.prototype).filter(function (method) {\n    var isNotPrivateMethod;\n    var isNonConstructorFunction = method !== \"constructor\" && typeof target.prototype[method] === \"function\";\n    var isNotAnIgnoredMethod = ignoreMethods.indexOf(method) === -1;\n\n    if (includePrivateMethods) {\n      isNotPrivateMethod = true;\n    } else {\n      isNotPrivateMethod = method.charAt(0) !== \"_\";\n    }\n\n    return isNonConstructorFunction && isNotPrivateMethod && isNotAnIgnoredMethod;\n  });\n  methods.forEach(function (method) {\n    var original = target.prototype[method];\n    target.prototype[method] = wrapPromise(original);\n  });\n  return target;\n};\n\nmodule.exports = wrapPromise;","map":{"version":3,"sources":["C:/Users/alpha/OneDrive/myapp/client/node_modules/@braintree/wrap-promise/dist/wrap-promise.js"],"names":["deferred_1","require","once_1","promise_or_callback_1","wrapPromise","fn","args","_i","arguments","length","callback","lastArg","pop","once","deferred","promiseOrCallback","apply","wrapPrototype","target","options","ignoreMethods","includePrivateMethods","transformPrivateMethods","methods","Object","getOwnPropertyNames","prototype","filter","method","isNotPrivateMethod","isNonConstructorFunction","isNotAnIgnoredMethod","indexOf","charAt","forEach","original","module","exports"],"mappings":"AAAA;;AACA,IAAIA,UAAU,GAAGC,OAAO,CAAC,gBAAD,CAAxB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,YAAD,CAApB;;AACA,IAAIE,qBAAqB,GAAGF,OAAO,CAAC,2BAAD,CAAnC;;AACA,SAASG,WAAT,CAAqBC,EAArB,EAAyB;AACrB;AACA,SAAO,YAAY;AACf,QAAIC,IAAI,GAAG,EAAX;;AACA,SAAK,IAAIC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGC,SAAS,CAACC,MAAhC,EAAwCF,EAAE,EAA1C,EAA8C;AAC1CD,MAAAA,IAAI,CAACC,EAAD,CAAJ,GAAWC,SAAS,CAACD,EAAD,CAApB;AACH;;AACD,QAAIG,QAAJ;AACA,QAAIC,OAAO,GAAGL,IAAI,CAACA,IAAI,CAACG,MAAL,GAAc,CAAf,CAAlB;;AACA,QAAI,OAAOE,OAAP,KAAmB,UAAvB,EAAmC;AAC/BD,MAAAA,QAAQ,GAAGJ,IAAI,CAACM,GAAL,EAAX;AACAF,MAAAA,QAAQ,GAAGR,MAAM,CAACW,IAAP,CAAYb,UAAU,CAACc,QAAX,CAAoBJ,QAApB,CAAZ,CAAX;AACH,KAVc,CAWf;AACA;AACA;AACA;;;AACA,WAAOP,qBAAqB,CAACY,iBAAtB,CAAwCV,EAAE,CAACW,KAAH,CAAS,IAAT,EAAeV,IAAf,CAAxC,EAA8DI,QAA9D,CAAP,CAfe,CAeiE;AACnF,GAhBD;AAiBH;;AACDN,WAAW,CAACa,aAAZ,GAA4B,UAAUC,MAAV,EAAkBC,OAAlB,EAA2B;AACnD,MAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;AAAEA,IAAAA,OAAO,GAAG,EAAV;AAAe;;AACzC,MAAIC,aAAa,GAAGD,OAAO,CAACC,aAAR,IAAyB,EAA7C;AACA,MAAIC,qBAAqB,GAAGF,OAAO,CAACG,uBAAR,KAAoC,IAAhE;AACA,MAAIC,OAAO,GAAGC,MAAM,CAACC,mBAAP,CAA2BP,MAAM,CAACQ,SAAlC,EAA6CC,MAA7C,CAAoD,UAAUC,MAAV,EAAkB;AAChF,QAAIC,kBAAJ;AACA,QAAIC,wBAAwB,GAAGF,MAAM,KAAK,aAAX,IAC3B,OAAOV,MAAM,CAACQ,SAAP,CAAiBE,MAAjB,CAAP,KAAoC,UADxC;AAEA,QAAIG,oBAAoB,GAAGX,aAAa,CAACY,OAAd,CAAsBJ,MAAtB,MAAkC,CAAC,CAA9D;;AACA,QAAIP,qBAAJ,EAA2B;AACvBQ,MAAAA,kBAAkB,GAAG,IAArB;AACH,KAFD,MAGK;AACDA,MAAAA,kBAAkB,GAAGD,MAAM,CAACK,MAAP,CAAc,CAAd,MAAqB,GAA1C;AACH;;AACD,WAAQH,wBAAwB,IAAID,kBAA5B,IAAkDE,oBAA1D;AACH,GAZa,CAAd;AAaAR,EAAAA,OAAO,CAACW,OAAR,CAAgB,UAAUN,MAAV,EAAkB;AAC9B,QAAIO,QAAQ,GAAGjB,MAAM,CAACQ,SAAP,CAAiBE,MAAjB,CAAf;AACAV,IAAAA,MAAM,CAACQ,SAAP,CAAiBE,MAAjB,IAA2BxB,WAAW,CAAC+B,QAAD,CAAtC;AACH,GAHD;AAIA,SAAOjB,MAAP;AACH,CAtBD;;AAuBAkB,MAAM,CAACC,OAAP,GAAiBjC,WAAjB","sourcesContent":["\"use strict\";\nvar deferred_1 = require(\"./lib/deferred\");\nvar once_1 = require(\"./lib/once\");\nvar promise_or_callback_1 = require(\"./lib/promise-or-callback\");\nfunction wrapPromise(fn) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var callback;\n        var lastArg = args[args.length - 1];\n        if (typeof lastArg === \"function\") {\n            callback = args.pop();\n            callback = once_1.once(deferred_1.deferred(callback));\n        }\n        // I know, I know, this looks bad. But it's a quirk of the library that\n        // we need to allow passing the this context to the original function\n        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n        // @ts-ignore: this has an implicit any\n        return promise_or_callback_1.promiseOrCallback(fn.apply(this, args), callback); // eslint-disable-line no-invalid-this\n    };\n}\nwrapPromise.wrapPrototype = function (target, options) {\n    if (options === void 0) { options = {}; }\n    var ignoreMethods = options.ignoreMethods || [];\n    var includePrivateMethods = options.transformPrivateMethods === true;\n    var methods = Object.getOwnPropertyNames(target.prototype).filter(function (method) {\n        var isNotPrivateMethod;\n        var isNonConstructorFunction = method !== \"constructor\" &&\n            typeof target.prototype[method] === \"function\";\n        var isNotAnIgnoredMethod = ignoreMethods.indexOf(method) === -1;\n        if (includePrivateMethods) {\n            isNotPrivateMethod = true;\n        }\n        else {\n            isNotPrivateMethod = method.charAt(0) !== \"_\";\n        }\n        return (isNonConstructorFunction && isNotPrivateMethod && isNotAnIgnoredMethod);\n    });\n    methods.forEach(function (method) {\n        var original = target.prototype[method];\n        target.prototype[method] = wrapPromise(original);\n    });\n    return target;\n};\nmodule.exports = wrapPromise;\n"]},"metadata":{},"sourceType":"script"}