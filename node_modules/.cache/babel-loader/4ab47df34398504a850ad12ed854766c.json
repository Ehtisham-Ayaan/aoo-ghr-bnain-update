{"ast":null,"code":"'use strict';\n\nlet Gateway = require('./gateway').Gateway;\n\nlet Dispute = require('./dispute').Dispute;\n\nlet DisputeSearch = require('./dispute_search').DisputeSearch;\n\nlet InvalidKeysError = require('./exceptions').InvalidKeysError;\n\nlet NotFoundError = require('./exceptions').NotFoundError;\n\nlet PaginatedResponse = require('./paginated_response').PaginatedResponse;\n\nlet wrapPrototype = require('@braintree/wrap-promise').wrapPrototype;\n\nclass DisputeGateway extends Gateway {\n  constructor(gateway) {\n    super();\n    this.gateway = gateway;\n    this.config = this.gateway.config;\n  }\n\n  accept(id) {\n    let notFoundError = new NotFoundError(\"dispute with id '\" + id + \"' not found\");\n\n    if (id == null || id.trim() === '') {\n      return Promise.reject(notFoundError);\n    }\n\n    return this.gateway.http.put(`${this.config.baseMerchantPath()}/disputes/${id}/accept`).then(this.createResponseHandler('dispute', Dispute)).catch(this.createRejectionHandler(notFoundError));\n  }\n\n  addTextEvidence(id, contentOrRequest) {\n    const isRequest = contentOrRequest != null && typeof contentOrRequest === 'object';\n    const request = isRequest ? contentOrRequest : {\n      content: contentOrRequest\n    };\n    let notFoundError = new NotFoundError(\"dispute with id '\" + id + \"' not found\");\n\n    if (id == null || id.trim() === '') {\n      return Promise.reject(notFoundError);\n    }\n\n    if (request.content == null || request.content.trim() === '') {\n      return Promise.reject(new InvalidKeysError('content cannot be null or empty'));\n    }\n\n    const evidence = {\n      comments: request.content\n    };\n\n    if (request.sequenceNumber != null) {\n      if (String(request.sequenceNumber) !== String(parseInt(request.sequenceNumber, 10))) {\n        return Promise.reject(new InvalidKeysError('sequenceNumber must be a number'));\n      }\n\n      evidence.sequence_number = parseInt(request.sequenceNumber, 10); // eslint-disable-line camelcase\n    }\n\n    if (request.category != null) {\n      if (typeof request.category !== 'string') {\n        return Promise.reject(new InvalidKeysError('category must be a string'));\n      } else if (request.category.trim() === '') {\n        return Promise.reject(new InvalidKeysError('category cannot be empty'));\n      }\n\n      evidence.category = request.category;\n    }\n\n    return this.gateway.http.post(`${this.config.baseMerchantPath()}/disputes/${id}/evidence`, {\n      evidence\n    }).then(this.createResponseHandler()).catch(this.createRejectionHandler(notFoundError));\n  }\n\n  addFileEvidence(disputeId, documentIdOrRequest) {\n    const isRequest = documentIdOrRequest != null && typeof documentIdOrRequest === 'object';\n    const request = isRequest ? documentIdOrRequest : {\n      documentId: documentIdOrRequest\n    };\n    let notFoundError = new NotFoundError(\"dispute with id '\" + disputeId + \"' not found\");\n\n    if (disputeId == null || disputeId.trim() === '') {\n      return Promise.reject(notFoundError);\n    }\n\n    if (request.documentId == null || request.documentId.trim() === '') {\n      return Promise.reject(new NotFoundError(\"document with id '\" + request.documentId + \"' not found\"));\n    }\n\n    const evidence = {\n      document_upload_id: request.documentId,\n      // eslint-disable-line camelcase\n      category: request.category\n    };\n    return this.gateway.http.post(`${this.config.baseMerchantPath()}/disputes/${disputeId}/evidence`, {\n      evidence\n    }).then(this.createResponseHandler()).catch(this.createRejectionHandler(notFoundError));\n  }\n\n  finalize(id) {\n    let notFoundError = new NotFoundError(`dispute with id '${id}' not found`);\n\n    if (id == null || id.trim() === '') {\n      return Promise.reject(notFoundError);\n    }\n\n    return this.gateway.http.put(`${this.config.baseMerchantPath()}/disputes/${id}/finalize`).then(this.createResponseHandler()).catch(this.createRejectionHandler(notFoundError));\n  }\n\n  find(id) {\n    let notFoundError = new NotFoundError(`dispute with id '${id}' not found`);\n\n    if (id == null || id.trim() === '') {\n      return Promise.reject(notFoundError);\n    }\n\n    return this.gateway.http.get(`${this.config.baseMerchantPath()}/disputes/${id}`).then(this.createResponseHandler('dispute', Dispute)).catch(this.createRejectionHandler(notFoundError));\n  }\n\n  removeEvidence(disputeId, evidenceId) {\n    let notFoundError = new NotFoundError(\"evidence with id '\" + evidenceId + \"' for dispute with id '\" + disputeId + \"' not found\");\n\n    if (disputeId == null || disputeId.trim() === '' || evidenceId == null || evidenceId.trim() === '') {\n      return Promise.reject(notFoundError);\n    }\n\n    return this.gateway.http.delete(`${this.config.baseMerchantPath()}/disputes/${disputeId}/evidence/${evidenceId}`).then(this.createResponseHandler()).catch(this.createRejectionHandler(notFoundError));\n  }\n\n  search(searchFunction, callback) {\n    let search = new DisputeSearch();\n    searchFunction(search);\n    let response = new PaginatedResponse(this.fetchDisputes.bind(this), {\n      search: search.toHash()\n    });\n\n    if (callback != null) {\n      return response.all(callback);\n    }\n\n    response.ready();\n    return response.stream;\n  }\n\n  fetchDisputes(pageNumber, search, callback) {\n    return this.gateway.http.post(`${this.config.baseMerchantPath()}/disputes/advanced_search?page=${pageNumber}`, {\n      search: search\n    }, (err, response) => {\n      if (err) {\n        return callback(err);\n      }\n\n      let totalItems = response.disputes.totalItems;\n      let pageSize = response.disputes.pageSize;\n      let disputes = response.disputes.dispute;\n\n      if (!disputes) {\n        disputes = [null];\n      } else if (!Array.isArray(disputes)) {\n        disputes = [disputes];\n      }\n\n      return callback(null, totalItems, pageSize, disputes);\n    });\n  }\n\n  createRejectionHandler(notFoundError) {\n    return function (err) {\n      if (err.type === 'notFoundError') {\n        err = notFoundError;\n      }\n\n      return Promise.reject(err);\n    };\n  }\n\n}\n\nmodule.exports = {\n  DisputeGateway: wrapPrototype(DisputeGateway, {\n    ignoreMethods: ['search', 'fetchDisputes']\n  })\n};","map":{"version":3,"sources":["C:/Users/alpha/OneDrive/myapp/client/node_modules/braintree/lib/braintree/dispute_gateway.js"],"names":["Gateway","require","Dispute","DisputeSearch","InvalidKeysError","NotFoundError","PaginatedResponse","wrapPrototype","DisputeGateway","constructor","gateway","config","accept","id","notFoundError","trim","Promise","reject","http","put","baseMerchantPath","then","createResponseHandler","catch","createRejectionHandler","addTextEvidence","contentOrRequest","isRequest","request","content","evidence","comments","sequenceNumber","String","parseInt","sequence_number","category","post","addFileEvidence","disputeId","documentIdOrRequest","documentId","document_upload_id","finalize","find","get","removeEvidence","evidenceId","delete","search","searchFunction","callback","response","fetchDisputes","bind","toHash","all","ready","stream","pageNumber","err","totalItems","disputes","pageSize","dispute","Array","isArray","type","module","exports","ignoreMethods"],"mappings":"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","sourcesContent":["'use strict';\n\nlet Gateway = require('./gateway').Gateway;\nlet Dispute = require('./dispute').Dispute;\nlet DisputeSearch = require('./dispute_search').DisputeSearch;\nlet InvalidKeysError = require('./exceptions').InvalidKeysError;\nlet NotFoundError = require('./exceptions').NotFoundError;\nlet PaginatedResponse = require('./paginated_response').PaginatedResponse;\nlet wrapPrototype = require('@braintree/wrap-promise').wrapPrototype;\n\nclass DisputeGateway extends Gateway {\n  constructor(gateway) {\n    super();\n    this.gateway = gateway;\n    this.config = this.gateway.config;\n  }\n\n  accept(id) {\n    let notFoundError = new NotFoundError(\"dispute with id '\" + id + \"' not found\");\n\n    if (id == null || id.trim() === '') {\n      return Promise.reject(notFoundError);\n    }\n\n    return this.gateway.http.put(`${this.config.baseMerchantPath()}/disputes/${id}/accept`)\n      .then(this.createResponseHandler('dispute', Dispute))\n      .catch(this.createRejectionHandler(notFoundError));\n  }\n\n  addTextEvidence(id, contentOrRequest) {\n    const isRequest = contentOrRequest != null && typeof contentOrRequest === 'object';\n    const request = isRequest ? contentOrRequest : {content: contentOrRequest};\n    let notFoundError = new NotFoundError(\"dispute with id '\" + id + \"' not found\");\n\n    if (id == null || id.trim() === '') {\n      return Promise.reject(notFoundError);\n    }\n\n    if (request.content == null || request.content.trim() === '') {\n      return Promise.reject(new InvalidKeysError('content cannot be null or empty'));\n    }\n\n    const evidence = {\n      comments: request.content\n    };\n\n    if (request.sequenceNumber != null) {\n      if (String(request.sequenceNumber) !== String(parseInt(request.sequenceNumber, 10))) {\n        return Promise.reject(new InvalidKeysError('sequenceNumber must be a number'));\n      }\n      evidence.sequence_number = parseInt(request.sequenceNumber, 10);  // eslint-disable-line camelcase\n    }\n\n    if (request.category != null) {\n      if (typeof request.category !== 'string') {\n        return Promise.reject(new InvalidKeysError('category must be a string'));\n      } else if (request.category.trim() === '') {\n        return Promise.reject(new InvalidKeysError('category cannot be empty'));\n      }\n      evidence.category = request.category;\n    }\n\n    return this.gateway.http.post(`${this.config.baseMerchantPath()}/disputes/${id}/evidence`, {\n      evidence\n    })\n      .then(this.createResponseHandler())\n      .catch(this.createRejectionHandler(notFoundError));\n  }\n\n  addFileEvidence(disputeId, documentIdOrRequest) {\n    const isRequest = documentIdOrRequest != null && typeof documentIdOrRequest === 'object';\n    const request = isRequest ? documentIdOrRequest : {documentId: documentIdOrRequest};\n    let notFoundError = new NotFoundError(\"dispute with id '\" + disputeId + \"' not found\");\n\n    if (disputeId == null || disputeId.trim() === '') {\n      return Promise.reject(notFoundError);\n    }\n\n    if (request.documentId == null || request.documentId.trim() === '') {\n      return Promise.reject(new NotFoundError(\"document with id '\" + request.documentId + \"' not found\"));\n    }\n\n    const evidence = {\n      document_upload_id: request.documentId, // eslint-disable-line camelcase\n      category: request.category\n    };\n\n    return this.gateway.http.post(`${this.config.baseMerchantPath()}/disputes/${disputeId}/evidence`, {\n      evidence\n    })\n      .then(this.createResponseHandler())\n      .catch(this.createRejectionHandler(notFoundError));\n  }\n\n  finalize(id) {\n    let notFoundError = new NotFoundError(`dispute with id '${id}' not found`);\n\n    if (id == null || id.trim() === '') {\n      return Promise.reject(notFoundError);\n    }\n\n    return this.gateway.http.put(`${this.config.baseMerchantPath()}/disputes/${id}/finalize`)\n      .then(this.createResponseHandler())\n      .catch(this.createRejectionHandler(notFoundError));\n  }\n\n  find(id) {\n    let notFoundError = new NotFoundError(`dispute with id '${id}' not found`);\n\n    if (id == null || id.trim() === '') {\n      return Promise.reject(notFoundError);\n    }\n\n    return this.gateway.http.get(`${this.config.baseMerchantPath()}/disputes/${id}`)\n      .then(this.createResponseHandler('dispute', Dispute))\n      .catch(this.createRejectionHandler(notFoundError));\n  }\n\n  removeEvidence(disputeId, evidenceId) {\n    let notFoundError = new NotFoundError(\"evidence with id '\" + evidenceId + \"' for dispute with id '\" + disputeId + \"' not found\");\n\n    if (disputeId == null || disputeId.trim() === '' || evidenceId == null || evidenceId.trim() === '') {\n      return Promise.reject(notFoundError);\n    }\n\n    return this.gateway.http.delete(`${this.config.baseMerchantPath()}/disputes/${disputeId}/evidence/${evidenceId}`)\n      .then(this.createResponseHandler())\n      .catch(this.createRejectionHandler(notFoundError));\n  }\n\n  search(searchFunction, callback) {\n    let search = new DisputeSearch();\n\n    searchFunction(search);\n\n    let response = new PaginatedResponse(this.fetchDisputes.bind(this), {\n      search: search.toHash()\n    });\n\n    if (callback != null) {\n      return response.all(callback);\n    }\n\n    response.ready();\n\n    return response.stream;\n  }\n\n  fetchDisputes(pageNumber, search, callback) {\n    return this.gateway.http.post(`${this.config.baseMerchantPath()}/disputes/advanced_search?page=${pageNumber}`, {search: search}, (err, response) => {\n      if (err) {\n        return callback(err);\n      }\n\n      let totalItems = response.disputes.totalItems;\n      let pageSize = response.disputes.pageSize;\n      let disputes = response.disputes.dispute;\n\n      if (!disputes) {\n        disputes = [null];\n      } else if (!Array.isArray(disputes)) {\n        disputes = [disputes];\n      }\n\n      return callback(null, totalItems, pageSize, disputes);\n    });\n  }\n\n  createRejectionHandler(notFoundError) {\n    return function (err) {\n      if (err.type === 'notFoundError') {\n        err = notFoundError;\n      }\n\n      return Promise.reject(err);\n    };\n  }\n}\n\nmodule.exports = {DisputeGateway: wrapPrototype(DisputeGateway, {\n  ignoreMethods: ['search', 'fetchDisputes']\n})};\n"]},"metadata":{},"sourceType":"script"}