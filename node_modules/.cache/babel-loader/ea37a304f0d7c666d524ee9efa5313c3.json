{"ast":null,"code":"'use strict';\n\nlet xml2js = require('xml2js');\n\nlet Digest = require('./digest').Digest;\n\nlet Gateway = require('./gateway').Gateway;\n\nlet exceptions = require('./exceptions');\n\nlet Util = require('./util').Util;\n\nlet WebhookNotification = require('./webhook_notification').WebhookNotification;\n\nlet wrapPrototype = require('@braintree/wrap-promise').wrapPrototype;\n\nclass WebhookNotificationGateway extends Gateway {\n  constructor(gateway) {\n    super();\n    this.gateway = gateway;\n    this.config = this.gateway.config;\n  }\n\n  parse(signature, payload) {\n    if (!signature) {\n      return Promise.reject(exceptions.InvalidSignatureError('signature parameter is required')); // eslint-disable-line new-cap\n    }\n\n    if (!payload) {\n      return Promise.reject(exceptions.InvalidSignatureError('payload parameter is required')); // eslint-disable-line new-cap\n    }\n\n    if (payload.match(/[^A-Za-z0-9+=\\/\\n]/)) {\n      return Promise.reject(exceptions.InvalidSignatureError('payload contains illegal characters')); // eslint-disable-line new-cap\n    }\n\n    let err = this.validateSignature(signature, payload);\n\n    if (err) {\n      return Promise.reject(err);\n    }\n\n    const xmlPayload = Buffer.from(payload, 'base64').toString('utf8');\n    return xml2js.parseStringPromise(xmlPayload, {\n      attrkey: '@',\n      charkey: '#',\n      explicitArray: false\n    }).then(result => {\n      const attributes = Util.convertNodeToObject(result);\n      const handler = this.createResponseHandler('notification', WebhookNotification);\n      return handler(attributes);\n    }).then(responseHandlerResponse => {\n      return responseHandlerResponse.notification;\n    });\n  }\n\n  validateSignature(signatureString, payload) {\n    let signaturePairs = signatureString.split('&').filter(pair => pair.indexOf('|') !== -1).map(pair => pair.split('|'));\n    let signature = this.matchingSignature(signaturePairs);\n\n    if (!signature) {\n      return exceptions.InvalidSignatureError('no matching public key'); // eslint-disable-line new-cap\n    }\n\n    let self = this;\n    const matches = [payload, `${payload}\\n`].some(data => Digest.secureCompare(signature, Digest.Sha1hexdigest(self.gateway.config.privateKey, data)));\n\n    if (!matches) {\n      return exceptions.InvalidSignatureError('signature does not match payload - one has been modified'); // eslint-disable-line new-cap\n    }\n\n    return null;\n  }\n\n  verify(challenge, callback) {\n    if (!challenge.match(/^[a-f0-9]{20,32}$/)) {\n      if (callback != null) {\n        callback(exceptions.InvalidChallengeError('challenge contains non-hex characters'), null); // eslint-disable-line new-cap\n\n        return;\n      }\n\n      throw exceptions.InvalidChallengeError('challenge contains non-hex characters'); // eslint-disable-line new-cap\n    }\n\n    let digest = Digest.Sha1hexdigest(this.gateway.config.privateKey, challenge);\n    return `${this.gateway.config.publicKey}|${digest}`; // eslint-disable-line consistent-return\n  }\n\n  matchingSignature(signaturePairs) {\n    for (let keyPair of signaturePairs) {\n      let publicKey = keyPair[0];\n      let signature = keyPair[1];\n\n      if (this.gateway.config.publicKey === publicKey) {\n        return signature;\n      }\n    }\n\n    return null;\n  }\n\n}\n\nmodule.exports = {\n  WebhookNotificationGateway: wrapPrototype(WebhookNotificationGateway, {\n    ignoreMethods: ['verify']\n  })\n};","map":{"version":3,"sources":["C:/Users/alpha/OneDrive/myapp/client/node_modules/braintree/lib/braintree/webhook_notification_gateway.js"],"names":["xml2js","require","Digest","Gateway","exceptions","Util","WebhookNotification","wrapPrototype","WebhookNotificationGateway","constructor","gateway","config","parse","signature","payload","Promise","reject","InvalidSignatureError","match","err","validateSignature","xmlPayload","Buffer","from","toString","parseStringPromise","attrkey","charkey","explicitArray","then","result","attributes","convertNodeToObject","handler","createResponseHandler","responseHandlerResponse","notification","signatureString","signaturePairs","split","filter","pair","indexOf","map","matchingSignature","self","matches","some","data","secureCompare","Sha1hexdigest","privateKey","verify","challenge","callback","InvalidChallengeError","digest","publicKey","keyPair","module","exports","ignoreMethods"],"mappings":"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","sourcesContent":["'use strict';\n\nlet xml2js = require('xml2js');\nlet Digest = require('./digest').Digest;\nlet Gateway = require('./gateway').Gateway;\nlet exceptions = require('./exceptions');\nlet Util = require('./util').Util;\nlet WebhookNotification = require('./webhook_notification').WebhookNotification;\nlet wrapPrototype = require('@braintree/wrap-promise').wrapPrototype;\n\nclass WebhookNotificationGateway extends Gateway {\n  constructor(gateway) {\n    super();\n    this.gateway = gateway;\n    this.config = this.gateway.config;\n  }\n\n  parse(signature, payload) {\n    if (!signature) {\n      return Promise.reject(exceptions.InvalidSignatureError('signature parameter is required')); // eslint-disable-line new-cap\n    }\n    if (!payload) {\n      return Promise.reject(exceptions.InvalidSignatureError('payload parameter is required')); // eslint-disable-line new-cap\n    }\n    if (payload.match(/[^A-Za-z0-9+=\\/\\n]/)) {\n      return Promise.reject(exceptions.InvalidSignatureError('payload contains illegal characters')); // eslint-disable-line new-cap\n    }\n    let err = this.validateSignature(signature, payload);\n\n    if (err) {\n      return Promise.reject(err);\n    }\n\n    const xmlPayload = Buffer.from(payload, 'base64').toString('utf8');\n\n    return xml2js.parseStringPromise(xmlPayload, {\n      attrkey: '@',\n      charkey: '#',\n      explicitArray: false\n    }).then(result => {\n      const attributes = Util.convertNodeToObject(result);\n      const handler = this.createResponseHandler('notification', WebhookNotification);\n\n      return handler(attributes);\n    }).then(responseHandlerResponse => {\n      return responseHandlerResponse.notification;\n    });\n  }\n\n  validateSignature(signatureString, payload) {\n    let signaturePairs = signatureString.split('&').filter((pair) => pair.indexOf('|') !== -1).map((pair) => pair.split('|'));\n    let signature = this.matchingSignature(signaturePairs);\n\n    if (!signature) {\n      return exceptions.InvalidSignatureError('no matching public key'); // eslint-disable-line new-cap\n    }\n\n    let self = this;\n    const matches = [\n      payload,\n      `${payload}\\n`\n    ].some((data) => Digest.secureCompare(signature, Digest.Sha1hexdigest(self.gateway.config.privateKey, data)));\n\n    if (!matches) {\n      return exceptions.InvalidSignatureError('signature does not match payload - one has been modified'); // eslint-disable-line new-cap\n    }\n\n    return null;\n  }\n\n  verify(challenge, callback) {\n    if (!challenge.match(/^[a-f0-9]{20,32}$/)) {\n      if (callback != null) {\n        callback(exceptions.InvalidChallengeError('challenge contains non-hex characters'), null); // eslint-disable-line new-cap\n\n        return;\n      }\n\n      throw exceptions.InvalidChallengeError('challenge contains non-hex characters'); // eslint-disable-line new-cap\n    }\n    let digest = Digest.Sha1hexdigest(this.gateway.config.privateKey, challenge);\n\n    return `${this.gateway.config.publicKey}|${digest}`; // eslint-disable-line consistent-return\n  }\n\n  matchingSignature(signaturePairs) {\n    for (let keyPair of signaturePairs) {\n      let publicKey = keyPair[0];\n      let signature = keyPair[1];\n\n      if (this.gateway.config.publicKey === publicKey) {\n        return signature;\n      }\n    }\n\n    return null;\n  }\n}\n\nmodule.exports = {WebhookNotificationGateway: wrapPrototype(WebhookNotificationGateway, {\n  ignoreMethods: ['verify']\n})};\n"]},"metadata":{},"sourceType":"script"}