{"ast":null,"code":"/* eslint-disable */\n\n/*\n * querystring-parse.js\n *  - node.js module providing \"parse\" method to turn query strings into js objects\n *\n * Chad Etzel\n *\n * Based on YUI \"querystring-parse.js\" module\n * http://github.com/isaacs/yui3/tree/master/src/querystring/js\n *\n * Copyright (c) 2009, Yahoo! Inc. and Chad Etzel\n * BSD License (see LICENSE.md for info)\n */\nvar util = require(\"util\"),\n    braintree_util = require(\"./util\");\n\nexports.parse = querystring_parse;\n/**\n * <p>The querystring module adds support for serializing JavaScript objects into\n * query strings and parsing JavaScript objects from query strings format.</p>\n *\n * <p>The <code>querystring</code> module is a rollup of <code>querystring-parse</code> and\n * <code>querystring-stringify</code>.</p>\n *\n * <p>As their names suggest, <code>querystring-parse</code> adds support for parsing\n * Query String data (querystring.parse) and <code>querystring-stringify</code> for serializing\n * JavaScript data into Query Strings (querystring.stringify).  You may choose to\n * include either of the submodules individually if you don't need the\n * complementary functionality, or include the rollup for both.</p>\n *\n * @module querystring\n */\n\n/**\n * Provides parse method to accept Query Strings and return native\n * JavaScript objects.\n *\n * @module querystring\n * @submodule querystring-parse\n * @for querystring\n * @static\n */\n\nfunction querystring_parse(qs, sep, eq, unesc) {\n  return qs.split(sep || \"&\").map(pieceParser(eq || \"=\", unesc || unescape)).reduce(mergeParams, {});\n}\n\n;\n\nfunction unescape(s) {\n  return decodeURIComponent(s.replace(/\\+/g, ' '));\n}\n\n; // Parse a key=val string.\n// These can get pretty hairy\n// example flow:\n// parse(foo[bar][][bla]=baz)\n// return parse(foo[bar][][bla],\"baz\")\n// return parse(foo[bar][], {bla : \"baz\"})\n// return parse(foo[bar], [{bla:\"baz\"}])\n// return parse(foo, {bar:[{bla:\"baz\"}]})\n// return {foo:{bar:[{bla:\"baz\"}]}}\n\nfunction pieceParser(eq, unesc) {\n  return function parsePiece(key, val) {\n    if (arguments.length !== 2) {\n      // key=val, called from the map/reduce\n      key = key.split(eq);\n      return parsePiece(unesc(key.shift()), unesc(key.join(eq)));\n    }\n\n    key = key.replace(/^\\s+|\\s+$/g, '');\n\n    if (braintree_util.isString(val)) {\n      val = val.replace(/^\\s+|\\s+$/g, ''); // convert numerals to numbers\n\n      if (!isNaN(val)) {\n        var numVal = +val;\n        if (val === numVal.toString(10)) val = numVal;\n      }\n    }\n\n    var sliced = /(.*)\\[([^\\]]*)\\]$/.exec(key);\n\n    if (!sliced) {\n      var ret = {};\n      if (key) ret[key] = val;\n      return ret;\n    } // [\"foo[][bar][][baz]\", \"foo[][bar][]\", \"baz\"]\n\n\n    var tail = sliced[2],\n        head = sliced[1]; // array: key[]=val\n\n    if (!tail) return parsePiece(head, [val]); // obj: key[subkey]=val\n\n    var ret = {};\n    ret[tail] = val;\n    return parsePiece(head, ret);\n  };\n}\n\n; // the reducer function that merges each query piece together into one set of params\n\nfunction mergeParams(params, addition) {\n  var ret;\n\n  if (!params) {\n    // if it's uncontested, then just return the addition.\n    ret = addition;\n  } else if (braintree_util.isArray(params)) {\n    // if the existing value is an array, then concat it.\n    ret = params.concat(addition);\n  } else if (!braintree_util.isObject(params) || !braintree_util.isObject(addition)) {\n    // if the existing value is not an array, and either are not objects, arrayify it.\n    ret = [params].concat(addition);\n  } else {\n    // else merge them as objects, which is a little more complex\n    ret = mergeObjects(params, addition);\n  }\n\n  return ret;\n}\n\n; // Merge two *objects* together. If this is called, we've already ruled\n// out the simple cases, and need to do the for-in business.\n\nfunction mergeObjects(params, addition) {\n  for (var i in addition) if (i && addition.hasOwnProperty(i)) {\n    params[i] = mergeParams(params[i], addition[i]);\n  }\n\n  return params;\n}\n\n;","map":{"version":3,"sources":["C:/Users/alpha/OneDrive/myapp/client/node_modules/braintree/vendor/querystring.node.js.511d6a2/querystring-parse.js"],"names":["util","require","braintree_util","exports","parse","querystring_parse","qs","sep","eq","unesc","split","map","pieceParser","unescape","reduce","mergeParams","s","decodeURIComponent","replace","parsePiece","key","val","arguments","length","shift","join","isString","isNaN","numVal","toString","sliced","exec","ret","tail","head","params","addition","isArray","concat","isObject","mergeObjects","i","hasOwnProperty"],"mappings":"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","sourcesContent":["/* eslint-disable */\n/*\n * querystring-parse.js\n *  - node.js module providing \"parse\" method to turn query strings into js objects\n *\n * Chad Etzel\n *\n * Based on YUI \"querystring-parse.js\" module\n * http://github.com/isaacs/yui3/tree/master/src/querystring/js\n *\n * Copyright (c) 2009, Yahoo! Inc. and Chad Etzel\n * BSD License (see LICENSE.md for info)\n */\n\n\nvar util = require(\"util\"),\n  braintree_util = require(\"./util\");\n\nexports.parse = querystring_parse;\n\n/**\n * <p>The querystring module adds support for serializing JavaScript objects into\n * query strings and parsing JavaScript objects from query strings format.</p>\n *\n * <p>The <code>querystring</code> module is a rollup of <code>querystring-parse</code> and\n * <code>querystring-stringify</code>.</p>\n *\n * <p>As their names suggest, <code>querystring-parse</code> adds support for parsing\n * Query String data (querystring.parse) and <code>querystring-stringify</code> for serializing\n * JavaScript data into Query Strings (querystring.stringify).  You may choose to\n * include either of the submodules individually if you don't need the\n * complementary functionality, or include the rollup for both.</p>\n *\n * @module querystring\n */\n\n/**\n * Provides parse method to accept Query Strings and return native\n * JavaScript objects.\n *\n * @module querystring\n * @submodule querystring-parse\n * @for querystring\n * @static\n */\nfunction querystring_parse (qs, sep, eq, unesc) {\n  return qs.split(sep || \"&\")\n    .map(pieceParser(eq || \"=\", unesc || unescape))\n    .reduce(mergeParams, {});\n};\n\nfunction unescape (s) {\n    return decodeURIComponent(s.replace(/\\+/g, ' '));\n};\n\n\n// Parse a key=val string.\n// These can get pretty hairy\n// example flow:\n// parse(foo[bar][][bla]=baz)\n// return parse(foo[bar][][bla],\"baz\")\n// return parse(foo[bar][], {bla : \"baz\"})\n// return parse(foo[bar], [{bla:\"baz\"}])\n// return parse(foo, {bar:[{bla:\"baz\"}]})\n// return {foo:{bar:[{bla:\"baz\"}]}}\nfunction pieceParser (eq, unesc) {\n  return function parsePiece (key, val) {\n    if (arguments.length !== 2) {\n      // key=val, called from the map/reduce\n      key = key.split(eq);\n      return parsePiece(\n        unesc(key.shift()),\n        unesc(key.join(eq))\n      );\n    }\n    key = key.replace(/^\\s+|\\s+$/g, '');\n    if (braintree_util.isString(val)) {\n      val = val.replace(/^\\s+|\\s+$/g, '');\n      // convert numerals to numbers\n      if (!isNaN(val)) {\n        var numVal = +val;\n        if (val === numVal.toString(10)) val = numVal;\n      }\n    }\n    var sliced = /(.*)\\[([^\\]]*)\\]$/.exec(key);\n    if (!sliced) {\n      var ret = {};\n      if (key) ret[key] = val;\n      return ret;\n    }\n    // [\"foo[][bar][][baz]\", \"foo[][bar][]\", \"baz\"]\n    var tail = sliced[2],\n      head = sliced[1];\n\n    // array: key[]=val\n    if (!tail) return parsePiece(head, [val]);\n\n    // obj: key[subkey]=val\n    var ret = {};\n    ret[tail] = val;\n    return parsePiece(head, ret);\n  };\n};\n\n// the reducer function that merges each query piece together into one set of params\nfunction mergeParams (params, addition) {\n\tvar ret;\n\n\tif (!params){\n\t\t// if it's uncontested, then just return the addition.\n\t\tret = addition;\n\t} else if (braintree_util.isArray(params)) {\n\t\t// if the existing value is an array, then concat it.\n\t\tret = params.concat(addition);\n\t} else if (!braintree_util.isObject(params) || !braintree_util.isObject(addition)) {\n\t\t// if the existing value is not an array, and either are not objects, arrayify it.\n\t\tret = [params].concat(addition);\n\t} else {\n\t\t// else merge them as objects, which is a little more complex\n\t\tret = mergeObjects(params, addition);\n\t}\n\treturn ret;\n};\n\n\n// Merge two *objects* together. If this is called, we've already ruled\n// out the simple cases, and need to do the for-in business.\nfunction mergeObjects (params, addition) {\n  for (var i in addition) if (i && addition.hasOwnProperty(i)) {\n    params[i] = mergeParams(params[i], addition[i]);\n  }\n  return params;\n};\n"]},"metadata":{},"sourceType":"script"}