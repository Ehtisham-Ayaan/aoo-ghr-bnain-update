{"ast":null,"code":"'use strict';\n\nlet Util = require('./util').Util;\n\nlet ValidationError = require('./validation_error').ValidationError;\n\nclass ValidationErrorsCollection {\n  constructor(errorAttributes) {\n    this.validationErrors = {};\n    this.errorCollections = {};\n\n    for (let key in errorAttributes) {\n      if (!errorAttributes.hasOwnProperty(key)) {\n        continue;\n      }\n\n      let val = errorAttributes[key];\n\n      if (key === 'errors') {\n        this.buildErrors(val);\n      } else {\n        this.errorCollections[key] = new ValidationErrorsCollection(val);\n      }\n    }\n  }\n\n  buildErrors(errors) {\n    return errors.map(item => {\n      let key = Util.toCamelCase(item.attribute);\n      this.validationErrors[key] = this.validationErrors[key] || [];\n      return this.validationErrors[key].push(new ValidationError(item));\n    });\n  }\n\n  deepErrors() {\n    let errors = [];\n\n    for (let key in this.validationErrors) {\n      if (!this.validationErrors.hasOwnProperty(key)) {\n        continue;\n      }\n\n      let val = this.validationErrors[key];\n      errors = errors.concat(val);\n    }\n\n    for (let key in this.errorCollections) {\n      if (!this.errorCollections.hasOwnProperty(key)) {\n        continue;\n      }\n\n      let val = this.errorCollections[key];\n      errors = errors.concat(val.deepErrors());\n    }\n\n    return errors;\n  }\n\n  for(name) {\n    return this.errorCollections[name];\n  }\n\n  forIndex(index) {\n    return this.errorCollections[`index${index}`];\n  }\n\n  on(name) {\n    return this.validationErrors[name];\n  }\n\n}\n\nmodule.exports = {\n  ValidationErrorsCollection: ValidationErrorsCollection\n};","map":{"version":3,"sources":["C:/Users/alpha/OneDrive/myapp/client/node_modules/braintree/lib/braintree/validation_errors_collection.js"],"names":["Util","require","ValidationError","ValidationErrorsCollection","constructor","errorAttributes","validationErrors","errorCollections","key","hasOwnProperty","val","buildErrors","errors","map","item","toCamelCase","attribute","push","deepErrors","concat","for","name","forIndex","index","on","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,IAAI,GAAGC,OAAO,CAAC,QAAD,CAAP,CAAkBD,IAA7B;;AACA,IAAIE,eAAe,GAAGD,OAAO,CAAC,oBAAD,CAAP,CAA8BC,eAApD;;AAEA,MAAMC,0BAAN,CAAiC;AAC/BC,EAAAA,WAAW,CAACC,eAAD,EAAkB;AAC3B,SAAKC,gBAAL,GAAwB,EAAxB;AACA,SAAKC,gBAAL,GAAwB,EAAxB;;AAEA,SAAK,IAAIC,GAAT,IAAgBH,eAAhB,EAAiC;AAC/B,UAAI,CAACA,eAAe,CAACI,cAAhB,CAA+BD,GAA/B,CAAL,EAA0C;AACxC;AACD;;AACD,UAAIE,GAAG,GAAGL,eAAe,CAACG,GAAD,CAAzB;;AAEA,UAAIA,GAAG,KAAK,QAAZ,EAAsB;AACpB,aAAKG,WAAL,CAAiBD,GAAjB;AACD,OAFD,MAEO;AACL,aAAKH,gBAAL,CAAsBC,GAAtB,IAA6B,IAAIL,0BAAJ,CAA+BO,GAA/B,CAA7B;AACD;AACF;AACF;;AAEDC,EAAAA,WAAW,CAACC,MAAD,EAAS;AAClB,WAAOA,MAAM,CAACC,GAAP,CAAYC,IAAD,IAAU;AAC1B,UAAIN,GAAG,GAAGR,IAAI,CAACe,WAAL,CAAiBD,IAAI,CAACE,SAAtB,CAAV;AAEA,WAAKV,gBAAL,CAAsBE,GAAtB,IAA6B,KAAKF,gBAAL,CAAsBE,GAAtB,KAA8B,EAA3D;AAEA,aAAO,KAAKF,gBAAL,CAAsBE,GAAtB,EAA2BS,IAA3B,CAAgC,IAAIf,eAAJ,CAAoBY,IAApB,CAAhC,CAAP;AACD,KANM,CAAP;AAOD;;AAEDI,EAAAA,UAAU,GAAG;AACX,QAAIN,MAAM,GAAG,EAAb;;AAEA,SAAK,IAAIJ,GAAT,IAAgB,KAAKF,gBAArB,EAAuC;AACrC,UAAI,CAAC,KAAKA,gBAAL,CAAsBG,cAAtB,CAAqCD,GAArC,CAAL,EAAgD;AAC9C;AACD;;AACD,UAAIE,GAAG,GAAG,KAAKJ,gBAAL,CAAsBE,GAAtB,CAAV;AAEAI,MAAAA,MAAM,GAAGA,MAAM,CAACO,MAAP,CAAcT,GAAd,CAAT;AACD;;AAED,SAAK,IAAIF,GAAT,IAAgB,KAAKD,gBAArB,EAAuC;AACrC,UAAI,CAAC,KAAKA,gBAAL,CAAsBE,cAAtB,CAAqCD,GAArC,CAAL,EAAgD;AAC9C;AACD;;AACD,UAAIE,GAAG,GAAG,KAAKH,gBAAL,CAAsBC,GAAtB,CAAV;AAEAI,MAAAA,MAAM,GAAGA,MAAM,CAACO,MAAP,CAAcT,GAAG,CAACQ,UAAJ,EAAd,CAAT;AACD;;AAED,WAAON,MAAP;AACD;;AAEDQ,EAAAA,GAAG,CAACC,IAAD,EAAO;AACR,WAAO,KAAKd,gBAAL,CAAsBc,IAAtB,CAAP;AACD;;AAEDC,EAAAA,QAAQ,CAACC,KAAD,EAAQ;AACd,WAAO,KAAKhB,gBAAL,CAAuB,QAAOgB,KAAM,EAApC,CAAP;AACD;;AAEDC,EAAAA,EAAE,CAACH,IAAD,EAAO;AACP,WAAO,KAAKf,gBAAL,CAAsBe,IAAtB,CAAP;AACD;;AA/D8B;;AAkEjCI,MAAM,CAACC,OAAP,GAAiB;AAACvB,EAAAA,0BAA0B,EAAEA;AAA7B,CAAjB","sourcesContent":["'use strict';\n\nlet Util = require('./util').Util;\nlet ValidationError = require('./validation_error').ValidationError;\n\nclass ValidationErrorsCollection {\n  constructor(errorAttributes) {\n    this.validationErrors = {};\n    this.errorCollections = {};\n\n    for (let key in errorAttributes) {\n      if (!errorAttributes.hasOwnProperty(key)) {\n        continue;\n      }\n      let val = errorAttributes[key];\n\n      if (key === 'errors') {\n        this.buildErrors(val);\n      } else {\n        this.errorCollections[key] = new ValidationErrorsCollection(val);\n      }\n    }\n  }\n\n  buildErrors(errors) {\n    return errors.map((item) => {\n      let key = Util.toCamelCase(item.attribute);\n\n      this.validationErrors[key] = this.validationErrors[key] || [];\n\n      return this.validationErrors[key].push(new ValidationError(item));\n    });\n  }\n\n  deepErrors() {\n    let errors = [];\n\n    for (let key in this.validationErrors) {\n      if (!this.validationErrors.hasOwnProperty(key)) {\n        continue;\n      }\n      let val = this.validationErrors[key];\n\n      errors = errors.concat(val);\n    }\n\n    for (let key in this.errorCollections) {\n      if (!this.errorCollections.hasOwnProperty(key)) {\n        continue;\n      }\n      let val = this.errorCollections[key];\n\n      errors = errors.concat(val.deepErrors());\n    }\n\n    return errors;\n  }\n\n  for(name) {\n    return this.errorCollections[name];\n  }\n\n  forIndex(index) {\n    return this.errorCollections[`index${index}`];\n  }\n\n  on(name) {\n    return this.validationErrors[name];\n  }\n}\n\nmodule.exports = {ValidationErrorsCollection: ValidationErrorsCollection};\n"]},"metadata":{},"sourceType":"script"}